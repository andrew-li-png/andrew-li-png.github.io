<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>endianness-v2 — picoCTF Forensics</title>

  <!-- Shared CSS/JS -->
  <link rel="stylesheet" href="../../../assets/styles.css" />
  <script defer src="../../../assets/site.js"></script>
</head>

<body>
  <div class="container">
    <header>
      <div class="tagline breadcrumbs">
        <a class="crumb" href="../../../index.html">Home</a>
        <a class="crumb" href="../../index.html">picoCTF</a>
        <a class="crumb" href="../index.html">Forensics</a>
        <span class="crumb-current">endianness-v2</span>
      </div>

      <h1>endianness-v2</h1>
      <p class="badges">
        <span class="badge">Endianness</span>
        <span class="badge">JPEG</span>
        <span class="badge">exiftool</span>
        <span class="badge">hexdump</span>
        <span class="badge">xxd</span>
      </p>

      <p class="muted">
        Goal: Recover the real file by fixing reversed 32-bit endianness, then open the reconstructed JPEG to reveal the flag.
      </p>
    </header>

    <div class="card">
      <h2>Challenge Description</h2>

      <p class="muted">Screenshot from the picoCTF challenge page:</p>

      <div class="screenshot">
        <img
          src="./endianness_v2/challenge.png"
          alt="Screenshot of the picoCTF challenge description for endianness-v2"
        />
      </div>
    </div>

    <div class="card">
      <h2>Challenge Overview</h2>
      <p>
        We’re given a mystery file named <code>challengefile</code>. Running <code>file</code> on it just says
        “data” (classic), but the title and description basically scream: <strong>the bytes are arranged wrong</strong>.
      </p>
      <p>
        The big clue came from metadata: <code>exiftool</code> warned about “JPEG-like data after an unknown 1-byte header.”
        That strongly suggests the underlying content is a JPEG, but the byte order is messed up.
      </p>
    </div>

    <div class="card">
      <h2>Solution</h2>

      <h3>1) Confirm the file type is “mystery meat”</h3>
      <p>
        First check: what does the OS think this file is?
      </p>

      <pre><code>file challengefile</code></pre>

      <div class="screenshot">
        <img
          src="./endianness_v2/step-01.png"
          alt="Terminal output showing 'file challengefile' returning 'data'"
        />
      </div>

      <h3>2) Pull clues from metadata with <code>exiftool</code></h3>
      <p>
        Even when a file won’t open normally, metadata tools can still leak hints.
        Here, <code>exiftool</code> basically told us what’s going on: it sees JPEG-like data, but something is off
        right at the start.
      </p>

      <pre><code>exiftool challengefile</code></pre>

      <div class="screenshot">
        <img
          src="./endianness_v2/step-02.png"
          alt="exiftool output warning about JPEG-like data after an unknown 1-byte header"
        />
      </div>

      <h3>3) Inspect the header and spot the pattern (endianness!)</h3>
      <p>
        JPEG magic bytes should start with <code>FF D8 FF E0</code>, but in the hex view I saw
        <code>E0 FF D8 FF</code>. At first I thought maybe it was just a swapped header… but more bytes showed the
        same problem throughout the file.
      </p>
      <p>
        Example: <code>43 00 DB FF</code> looks like the 4-byte reverse of <code>FF DB 00 43</code> (a common JPEG marker block).
        That’s the giveaway: this isn’t a tiny corruption — the file is stored with reversed <strong>32-bit endianness</strong>
        consistently across the whole file.
      </p>

      <div class="screenshot">
        <img
          src="./endianness_v2/step-03.png"
          alt="Hex view showing reversed JPEG header bytes (e0 ff d8 ff) and other reversed 4-byte patterns"
        />
      </div>

      <h3>4) Reconstruct the original bytes (swap every 4-byte word)</h3>
      <p>
        Since the bytes are reversed in 4-byte chunks, the fix is to reinterpret the file as a stream of 32-bit words,
        swap the endianness, and write it back out. This one-liner does exactly that:
      </p>

      <pre><code>hexdump -v -e '1/4 "%08x"' challengefile | xxd -r -p &gt; fixed.jpg</code></pre>

      <p class="muted">
        Translation: read 4 bytes at a time, print them as hex words, then rebuild raw bytes from that hex stream into <code>fixed.jpg</code>.
      </p>

      <h3>5) Open the recovered JPEG</h3>
      <p>
        After generating <code>fixed.jpg</code>, it opened normally — and the flag was sitting right there.
      </p>

      <div class="screenshot">
        <img
          src="./endianness_v2/result.png"
          alt="Recovered JPEG image showing the picoCTF flag"
        />
      </div>

      <h3>Flag</h3>
      <p>
        <code>picoCTF{cert!f1Ed_iNd!4n_s0rrY_3nDian_94cc03f3}</code>
      </p>
    </div>

    <div class="card">
      <h2>Tools Used</h2>
      <ul>
        <li><code>file</code> (quick triage)</li>
        <li><code>exiftool</code> (format hints from metadata/warnings)</li>
        <li>Hex viewer / hex editor (identify swapped 4-byte patterns)</li>
        <li><code>hexdump</code> + <code>xxd</code> (reconstruct the original JPEG)</li>
      </ul>
    </div>

    <footer>
      <p>Write-up by Andrew Li</p>
    </footer>
  </div>
</body>
</html>
