<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>eavesdrop — picoCTF Forensics</title>

  <!-- Shared CSS/JS -->
  <link rel="stylesheet" href="../../../assets/styles.css" />
  <script defer src="../../../assets/site.js"></script>
</head>

<body>
  <div class="container">
    <header>
      <div class="tagline breadcrumbs">
        <a class="crumb" href="../../../index.html">Home</a>
        <a class="crumb" href="../../index.html">picoCTF</a>
        <a class="crumb" href="../index.html">Forensics</a>
        <span class="crumb-current">eavesdrop</span>
      </div>

      <h1>Eavesdrop</h1>

      <p class="badges">
        <span class="badge">PCAP</span>
        <span class="badge">Wireshark</span>
        <span class="badge">strings</span>
        <span class="badge">OpenSSL</span>
      </p>

      <p class="muted">
        Goal: Extract an encrypted blob transferred over TCP, then decrypt it using an OpenSSL command leaked in plaintext chat.
      </p>
    </header>

    <div class="card">
      <h2>Challenge Description</h2>
      <p class="muted">Screenshot from the picoCTF challenge page:</p>

      <div class="screenshot">
        <img
          src="./eavesdrop/challenge.png"
          alt="Screenshot of the picoCTF challenge page for Eavesdrop"
        />
      </div>
    </div>

    <div class="card">
      <h2>Challenge Overview</h2>
      <p>
        This PCAP contains two things:
      </p>
      <ul>
        <li>a plaintext “chat” embedded inside packet data</li>
        <li>a short file transfer that contains the encrypted flag</li>
      </ul>
      <p>
        You <em>can</em> read the chat directly in Wireshark’s ASCII pane, but the fastest workflow is to run
        <code>strings</code> on the capture first. That quickly reveals an OpenSSL decrypt command (including the password),
        which tells us exactly how the transferred file needs to be decrypted.
      </p>
    </div>

    <div class="card">
      <h2>Solution</h2>

      <h3>1) Triage the PCAP with <code>strings</code></h3>
      <p>
        First, I pulled readable text out of the capture. I used <code>-n 7</code> to reduce short/noisy matches and keep the useful lines.
        This immediately surfaced a plaintext conversation, including an OpenSSL command and the password:
        <code>supersecretpassword123</code>.
      </p>

      <pre><code>strings capture.flag.pcap -n 7</code></pre>

      <div class="screenshot">
        <img
          src="./eavesdrop/step-01.png"
          alt="Terminal output from strings showing the plaintext chat and the OpenSSL des3 decrypt command with password"
        />
      </div>

      <h3>2) Confirm the plaintext chat in Wireshark (ASCII pane)</h3>
      <p>
        To verify where that text lives inside the capture, I opened the PCAP in Wireshark and inspected packet bytes.
        The conversation is visible directly in the ASCII pane of relevant packets (so this is another valid way to discover the decrypt command).
      </p>

      <div class="screenshot">
        <img
          src="./eavesdrop/step-02.png"
          alt="Wireshark view showing the plaintext chat inside packet bytes in the ASCII pane"
        />
      </div>

      <h3>3) Locate the file transfer (port <code>9002</code>)</h3>
      <p>
        In the chat, the sender mentions transferring the file over port <code>9002</code>. Since the capture is small (~75 packets),
        it’s quick to scroll/filter until the packets involving <code>9002</code> appear. The actual payload transfer happens in packet 57.
      </p>

      <div class="screenshot">
        <img
          src="./eavesdrop/step-03.png"
          alt="Wireshark packet list highlighting the port 9002 traffic and the packet containing the transfer payload"
        />
      </div>

      <h3>4) Follow the TCP stream and save the raw payload</h3>
      <p>
        I right-clicked packet 57 and used <strong>Follow → TCP Stream</strong> to isolate the transferred data.
        In the stream window, I set <em>Show as</em> to <strong>Raw</strong>, then clicked <strong>Save as…</strong>
        and saved it locally. I named the saved file <code>encrypted</code>.
      </p>

      <div class="screenshot">
        <img
          src="./eavesdrop/step-04.png"
          alt="Wireshark Follow TCP Stream window showing the raw payload and the option to Save as"
        />
      </div>

      <h3>5) Decrypt with OpenSSL and read the flag</h3>
      <p>
        Finally, I reused the command from the chat and pointed <code>-in</code> to my saved file (<code>encrypted</code>),
        outputting to <code>flag.txt</code>. The OpenSSL warning about deprecated key derivation can be ignored for this challenge.
      </p>

      <pre><code>openssl des3 -d -salt -in encrypted -out flag.txt -k supersecretpassword123
cat flag.txt</code></pre>

      <div class="screenshot">
        <img
          src="./eavesdrop/step-05.png"
          alt="Terminal output showing OpenSSL des3 decryption and cat flag.txt revealing the picoCTF flag"
        />
      </div>

      <h3>Flag</h3>
      <p>
        <code>picoCTF{nc_73115_411_5786acc3}</code>
      </p>
    </div>

    <div class="card">
      <h2>Tools Used</h2>
      <ul>
        <li><code>strings</code> (quickly extract the plaintext chat + decrypt command from the PCAP)</li>
        <li><code>Wireshark</code> (inspect packets, identify port <code>9002</code>, and extract the payload via Follow TCP Stream)</li>
        <li><code>OpenSSL</code> (decrypt the saved payload using the leaked password)</li>
      </ul>
    </div>

    <footer>
      <p>Write-up by Andrew Li</p>
    </footer>
  </div>
</body>
</html>
